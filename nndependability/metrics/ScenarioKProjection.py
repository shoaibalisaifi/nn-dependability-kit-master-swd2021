import os
import numpy as np 
import scipy
import math
import scipy.misc
import xml.etree.ElementTree as ET
from xml.dom import minidom
from ..atg import milp


"""
ATVA'18 re-implementation from Java to Python 3.x
"""
class Scenario_KProjection_Metric():
    """For the set of inputs with semantic information contained, compute the quantitative k-projection coverage.
    """

    def __init__(self, scenarioDescrptionFileName, kValue = 2):
    

        self.kValue = kValue   
    
        self.sd = ScenarioDescription(scenarioDescrptionFileName)

        maxType = [0] * len(self.sd.operatingConditionCriteria)

        for i in range(len(maxType)):
            maxType[i] = len(self.sd.operatingConditionItems[self.sd.operatingConditionCriteria[i]])

            
        self.cm = CoverageManagement(self.kValue, len(maxType), maxType);            

        # Domain restriction
        self.dr = DomainRestrictions()
        
    def addDomainRestrictionsFromFile(self, fileName):
        self.dr.addDomainRestrictionsFromFile(fileName, self.sd.operatingConditionCriteria, self.sd.operatingConditionItems)

    
    def addScenariosFromFile(self, fileName):

        allScenarios = []

        # Read and process input file
        tree = ET.parse(fileName)
        root = tree.getroot()

        for child in root:
               
            if child.tag != "scenario":
                raise Exception("Error in parsing the XML")
                
            scenario = [-1] * len(self.sd.operatingConditionCriteria)
            for subchild in child:
                operatingCondition = subchild.tag
                if(operatingCondition == "data_source"):
                    continue
                    
                value = subchild.text.strip()
                scenario[self.sd.operatingConditionCriteria.index(operatingCondition)] = self.sd.operatingConditionItems[operatingCondition].index(value)            
            allScenarios.append(scenario)
        
        for scenario in allScenarios:
            self.cm.insertTestCase(scenario)
            
        self.cm.printMetricQuantity()
        
    def writeScenarioToFile(self, variableAssignment, outputFile):

        top = ET.Element("scenarios")
        comment = ET.Comment("New scenario generated by MILP")
        top.append(comment)
        
        scenario = ET.SubElement(top, "scenario")
        for criterion in self.sd.operatingConditionCriteria:
            for assignment in self.sd.operatingConditionItems[criterion]: 
                var = milp.createValueAssignmentVariable(self.sd.operatingConditionCriteria.index(criterion), self.sd.operatingConditionItems[criterion].index(assignment))
                if(variableAssignment[var] == 1):
                    child = ET.SubElement(scenario, str(criterion))
                    child.text = str(assignment)
                    # print("for criterion "+str(criterion)+", set it to "+str(assignment))

        newScenario = ET.tostring(top, "utf-8")
        reparsed = minidom.parseString(newScenario)
        #print(reparsed.toprettyxml(indent="  "))
        if os.path.dirname(outputFile):
            os.makedirs(os.path.dirname(outputFile), exist_ok=True)
        secnarioFile = open(outputFile, "w")
        secnarioFile.write(reparsed.toprettyxml(indent="  "))
        secnarioFile.close()
        
class CoverageManagement:
    """For the set of inputs with semantic information contained, compute the quantitative k-projection coverage.

    Attributes:
        kValue: The constant k value for creating the coverage table
        numberOfCategorizations:
        maxType: 
        projectionRecords:
    """
    def __init__(self, kValue, numberOfCategorizations, maxType):
        

        if not ((kValue == 1 or kValue == 2) or kValue == 3):
            raise Exception('for k-projection coverage where k > 3, it is not supported')
            
        self.kValue = kValue
        self.numberOfCategorizations = numberOfCategorizations
        self.maxType = maxType
        self.projectionRecords = {}

        if (kValue == 1): 
            for i in range(numberOfCategorizations):  
                projectionType = [0] * 1
                projectionType[0] = maxType[i]
                self.projectionRecords[str(i)] = ProjectionRecord(kValue, projectionType)
            

        elif (kValue == 2): 
            for i in range(numberOfCategorizations):  
                for j in range(i+1, numberOfCategorizations):  
                    projectionType = [0] * 2
                    projectionType[0] = maxType[i]
                    projectionType[1] = maxType[j]
                    self.projectionRecords[str(i)+"_"+str(j)] = ProjectionRecord(kValue, projectionType)

            
        elif (kValue == 3): 
            for i in range(numberOfCategorizations):  
                for j in range(i+1, numberOfCategorizations):  
                    for k in range(j+1, numberOfCategorizations):  
                        projectionType = [0] * 3
                        projectionType[0] = maxType[i]
                        projectionType[1] = maxType[j]
                        projectionType[2] = maxType[k]
                        self.projectionRecords[str(i)+"_"+str(j)+"_"+str(k)] = ProjectionRecord(kValue, projectionType)
                    
    
    def printMetricQuantity(self):
    
        
        improvedItem = 0
        totalItems = 0
        for projectedCategorization, projRec in self.projectionRecords.items():
            #print(projectedCategorization)
            #print("\t"+str(projRec.currentlyOccupiedEntities))
            #print("\t"+str(projRec.maxOccupiedEntities))
            for value, currentQuantity in projRec.currentlyOccupiedEntities.items():
                totalItems = totalItems + projRec.maxOccupiedEntities[value]
                if (currentQuantity < projRec.maxOccupiedEntities[value]) :
                    # This item can be improved
                    improvedItem = improvedItem + (projRec.maxOccupiedEntities[value] - currentQuantity)
        
        
        print(str(self.kValue) + "-projection coverage (without considering domain restrictions): " + str(totalItems - improvedItem) + "/" + str(totalItems))


    def addDomainRestrictionConstraints(self):
        print("dummy")
    
    def insertTestCase(self, inputVector):
        
        #print(inputVector)
        
        if self.numberOfCategorizations != len(inputVector):
            return False
            
        if (self.kValue == 1) :
            for i in range(self.numberOfCategorizations):  
                self.projectionRecords[str(i)].currentlyOccupiedEntities[str(inputVector[i])] =  self.projectionRecords[str(i)].currentlyOccupiedEntities[str(inputVector[i])] + 1 
            return True
        elif (self.kValue == 2): 
            for i in range(self.numberOfCategorizations):  
                for j in range(i+1, self.numberOfCategorizations):  
                    self.projectionRecords[str(i)+ "_" + str(j)].currentlyOccupiedEntities[str(inputVector[i])+"_"+str(inputVector[j])] =  (
                        self.projectionRecords[str(i)+ "_" + str(j)].currentlyOccupiedEntities[str(inputVector[i])+"_"+str(inputVector[j])]  + 1)
            return True
        elif (self.kValue == 3): 
            for i in range(self.numberOfCategorizations):  
                for j in range(i+1, self.numberOfCategorizations):  
                    for k in range(j+1, self.numberOfCategorizations):  
                        self.projectionRecords[str(i)+ "_" + str(j)+"_" + str(k)].currentlyOccupiedEntities[str(inputVector[i])+"_"+str(inputVector[j])+"_"+str(inputVector[k])] = (
                            self.projectionRecords[str(i)+ "_" + str(j)+"_" + str(k)].currentlyOccupiedEntities[str(inputVector[i])+"_"+str(inputVector[j])+"_"+str(inputVector[k])]  + 1 )
            return True
        else: 
            return False
        

    def dumpMetricState(self):
        print(self.projectionRecords)

    
        
class ProjectionRecord():
    """Single table belonging to a particular projection.

    Attributes:
        kValue: The constant k value for creating the coverage table

    """

    def __init__(self, kValue, maxType):
            
        if not ((kValue == 1 or kValue == 2) or kValue == 3):
            raise Exception('for k-projection coverage where k > 3, it is not supported')
            
        self.kValue = kValue    
        self.currentlyOccupiedEntities = {}
        self.maxOccupiedEntities = {}
        
        if self.kValue == 1: 
            for i in range(maxType[0]):
                self.currentlyOccupiedEntities[str(i)] = 0
                # FIXME: Change below value from 1 to others when quantitative projection is required.
                self.maxOccupiedEntities[str(i)] = 1

            

        elif self.kValue == 2: 
            for i in range(maxType[0]):
                for j in range(maxType[1]):
                    self.currentlyOccupiedEntities[str(i)+"_"+str(j)] = 0
                    # FIXME: Change below value from 1 to others when quantitative projection is required.
                    self.maxOccupiedEntities[str(i)+"_"+str(j)] = 1
                
            
        elif self.kValue == 3:
            for i in range(maxType[0]):
                for j in range(maxType[1]):
                    for k in range(maxType[2]):
                        self.currentlyOccupiedEntities[str(i)+"_"+str(j)+"_"+str(k)] = 0
                        # FIXME: Change below value from 1 to others when quantitative projection is required.
                        self.maxOccupiedEntities[str(i)+"_"+str(j)+"_"+str(k)] = 1
        else:
            raise Exception("Currently k>3 is not supported")

            
class ScenarioDescription():       

    def __init__(self, fileName):
        self.operatingConditionCriteria = [];
        self.operatingConditionItems = {};

        # Read and process input file
        tree = ET.parse(fileName)
        root = tree.getroot()

        for child in root:
            nodeName = child.tag
            options = [x.strip() for x in child.text.split(',')]
            self.operatingConditionItems[nodeName] = options
            self.operatingConditionCriteria.append(nodeName);
       
        for key, value in self.operatingConditionItems.items():
            if len(value) >= 10:
                raise Exception("Currently the system is not able to process a condition with more than 10 elements due to internal string processing")
       
    def printScenarioDescription(self):
        print(str(self.operatingConditionCriteria))
        print(str(self.operatingConditionItems))
    
    
class DomainRestrictions():    

    def __init__(self):
        self.domainRestrictions = []
 
    def addDomainRestrictionsFromFile(self, fileName, operatingConditionCriteria, operatingConditionItems):
 

        # Read and process input file
        tree = ET.parse(fileName)
        root = tree.getroot()
        
        for child in root:
               
            if child.tag != "constraint":
                raise Exception("Error in parsing the XML")
                
            ex = milp.Expression()    
            
            for subchild in child:
                tag = subchild.tag
                value = subchild.text.strip()
                if tag == "upperbound":
                    if value == "MAX":
                        ex.upperbound = math.inf
                    elif value == "MIN":
                        ex.upperbound = -math.inf
                    else:
                        ex.upperbound = float(value)
                elif tag == "lowerbound":
                    if value == "MAX":
                        ex.lowerbound = math.inf
                    elif value == "MIN":
                        ex.lowerbound = -math.inf
                    else:
                        ex.lowerbound = float(value)
                elif tag == "item":
                    options = [x.strip() for x in value.split(',')]
                    coefficient = float(options[0])
                    criteria = options[1].split('.')[0]
                    value = options[1].split('.')[1]
                    ex.variables.append(milp.createValueAssignmentVariable(operatingConditionCriteria.index(criteria), operatingConditionItems[criteria].index(value)))
                    ex.coefficients.append(coefficient)
                    
                else:
                    raise Exception("Error in parsing the XML")

            ex.printExpression()
            self.domainRestrictions.append(ex)       
   
